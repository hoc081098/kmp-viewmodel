{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kmp-viewmodel \ud83d\udd06","text":""},{"location":"#kotlin-multiplatform-viewmodel-kotlin-multiplatform-mvvm-compose-multiplatform-viewmodel","title":"Kotlin Multiplatform ViewModel - Kotlin Multiplatform MVVM - Compose Multiplatform ViewModel","text":"<p>Common/ Shared ViewModel in Kotlin Multiplatform - A Kotlin Multiplatform library that provides shared MVVM for UI applications. Components are lifecycle-aware on Android. Supports Android Parcelable, Kotlin Parcelize, AndroidX SavedStateHandle for restoring state after process death. Easy interoperability with Swift/Objective-C and SwiftUI. Supports Compose Multiplatform Framework (Android, Desktop, Web, iOS, macOS, tvOS, watchOS).</p> <p>The ViewModel class is a business logic or screen level state holder. It exposes state to the UI and encapsulates related business logic. Its principal advantage is that it caches state and persists it through configuration changes (on Android).</p>"},{"location":"#kmp-viewmodel-and-navigation-for-jetbrains-compose-multiplatform-httpsgithubcomhoc081098solivagant","title":"kmp-viewmodel and Navigation for JetBrains Compose Multiplatform \ud83d\udc49 https://github.com/hoc081098/solivagant","text":""},{"location":"#author-petrus-nguyen-thai-hoc","title":"Author: Petrus Nguy\u1ec5n Th\u00e1i H\u1ecdc","text":"<p>Liked some of my work? Buy me a coffee (or more likely a beer)</p> <p></p>"},{"location":"#supported-targets","title":"Supported targets","text":"<ul> <li><code>android</code>.</li> <li><code>jvm</code> (must add <code>kotlinx-coroutines-swing</code>/<code>kotlinx-coroutines-javafx</code> to your dependencies to   make sure <code>Dispatchers.Main</code> available).</li> </ul> <p>[!NOTE] If you are targeting <code>Desktop</code> and:   - not using <code>JetBrains Compose Multiplatform</code>, you should provide the dependency <code>org.jetbrains.kotlinx:kotlinx-coroutines-swing</code> or <code>org.jetbrains.kotlinx:kotlinx-coroutines-javafx</code>.   - using <code>JetBrains Compose Multiplatform</code>, you should provide <code>org.jetbrains.kotlinx:kotlinx-coroutines-swing</code>.</p> <p>Because the <code>ViewModel.viewModelScope</code> depends on <code>Dispatchers.Main</code> provided by that libraries on Desktop.</p> <ul> <li><code>js</code> (<code>IR</code>).</li> <li><code>Darwin</code> targets:<ul> <li><code>iosArm64</code>, <code>iosX64</code>, <code>iosSimulatorArm64</code>.</li> <li><code>watchosArm32</code>, <code>watchosArm64</code>, <code>watchosX64</code>, <code>watchosSimulatorArm64</code>.</li> <li><code>tvosX64</code>, <code>tvosSimulatorArm64</code>, <code>tvosArm64</code>.</li> <li><code>macosX64</code>, <code>macosArm64</code>.</li> </ul> </li> </ul>"},{"location":"#docs","title":"Docs","text":""},{"location":"#0x-release-docs-httpshoc081098githubiokmp-viewmodeldocs0x","title":"0.x release docs: https://hoc081098.github.io/kmp-viewmodel/docs/0.x","text":""},{"location":"#snapshot-docs-httpshoc081098githubiokmp-viewmodeldocslatest","title":"Snapshot docs: https://hoc081098.github.io/kmp-viewmodel/docs/latest","text":""},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#1-kmp-viewmodel-library","title":"1. <code>kmp-viewmodel</code> library","text":"<p>For more information check out the docs.</p>"},{"location":"#2-kmp-viewmodel-savedstate-library","title":"2. <code>kmp-viewmodel-savedstate</code> library","text":"<p>For more information check out the docs.</p>"},{"location":"#3-kmp-viewmodel-and-swift-interoperability","title":"3. <code>kmp-viewmodel</code> and <code>Swift</code> interoperability","text":"<p>For more information check out the docs.</p>"},{"location":"#4-kmp-viewmodel-compose-library","title":"4. <code>kmp-viewmodel-compose</code> library","text":"<p>For more information check out the docs.</p>"},{"location":"#5-kmp-viewmodel-koin-compose-library","title":"5. <code>kmp-viewmodel-koin-compose</code> library","text":"<p>For more information check out the docs.</p>"},{"location":"#6-kmp-viewmodel-and-navigation-for-jetbrains-compose-multiplatform","title":"6. <code>kmp-viewmodel</code> and Navigation for JetBrains Compose Multiplatform.","text":"<p>For more information check out https://github.com/hoc081098/solivagant library.</p>"},{"location":"#sample","title":"Sample","text":"<ul> <li>KMM sample: shares business logic and <code>ViewHolder</code>s, using Jetpack Compose for Android and SwiftUi for iOS.</li> <li>Compose Multiplatform sample: shares <code>ViewModel</code>s and integrates with <code>Navigation</code> in Compose Multiplatform.</li> <li>Compose Multiplatform KmpViewModel KMM Unsplash Sample: A KMP template of the Unsplash App using Compose multiplatform for Android, Desktop, iOS. Share everything including data, domain, presentation, and UI.</li> <li>\ud83c\udf6d GithubSearchKMM: Github Repos Search KMM for Android and iOS. Kotlin Multiplatform Mobile using Jetpack Compose, SwiftUI, FlowRedux, Coroutines Flow, Dagger Hilt, Koin Dependency Injection, shared KMP ViewModel, Clean Architecture.</li> </ul>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li>[x] support <code>SaveStateHandle</code> (since 0.2.0).</li> <li>[x] add extensions for <code>Flow</code>/<code>StateFlow</code>, to use the ViewModel easily on <code>ios</code>/<code>macOS</code>/<code>tvOS</code>/<code>watchOS</code> platforms   (since 0.3.0).</li> <li>[x] support <code>Compose Multiplatform Framework</code> (since 0.5.0).</li> <li>[ ] support Koin integration with ViewModel and JetBrains Compose Multiplatform.</li> </ul>"},{"location":"#license","title":"License","text":"<pre><code>MIT License\nCopyright (c) 2023-2024 Petrus Nguy\u1ec5n Th\u00e1i H\u1ecdc\n</code></pre>"},{"location":"changelog/","title":"Change Log","text":""},{"location":"changelog/#unreleased-tbd","title":"Unreleased - TBD","text":""},{"location":"changelog/#061-dec-10-2023","title":"0.6.1 - Dec 10, 2023","text":""},{"location":"changelog/#viewmodel","title":"viewmodel","text":"<ul> <li>On non-Android targets: <code>ViewModel.viewModelScope</code> does not use <code>Dispatchers.Default</code> as a fallback.   That means the <code>CoroutineDispatcher</code> of <code>ViewModel.viewModelScope</code> is <code>Dispatchers.Main.immediate</code> or <code>Dispatchers.Main</code>.</li> </ul>"},{"location":"changelog/#example-docs","title":"Example, docs","text":"<ul> <li>Refactor example code.</li> <li>Add NOTE about the <code>kotlinx-coroutines</code> dependency when targeting <code>Desktop</code> (aka. <code>jvm</code>).</li> </ul>"},{"location":"changelog/#060-dec-8-2023","title":"0.6.0 - Dec 8, 2023","text":""},{"location":"changelog/#update-dependencies","title":"Update dependencies","text":"<ul> <li>Supports for Kotlin <code>1.9.21</code>.</li> <li>AndroidX Lifecycle <code>2.6.2</code>.</li> <li>JetBrains Compose Multiplatform <code>1.5.11</code>.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Remove now-unsupported targets: <code>iosArm32</code>, <code>watchosX86</code>.</li> </ul>"},{"location":"changelog/#viewmodel_1","title":"viewmodel","text":"<ul> <li> <p><code>MutableCreationExtras</code> has been renamed to <code>MutableCreationExtrasBuilder</code>,   and it does not inherit from <code>CreationExtras</code> anymore.   Because of this, a new method   <code>MutableCreationExtrasBuilder.asCreationExtras()</code> has been introduced can be used to convert   a builder back to <code>CreationExtras</code> as needed.</p> <p>NOTE: <code>buildCreationExtras</code> and <code>CreationExtras.edit</code> methods are still the same as before.</p> <pre><code>// Old version (0.5.0)\nval creationExtras: CreationExtras = MutableCreationExtras().apply {\n  // ...\n}\n\n// New version (0.6.0): `MutableCreationExtras` does not inherit from `CreationExtras` anymore.\nval creationExtras: CreationExtras = MutableCreationExtrasBuilder().apply {\n  // ...\n}.asCreationExtras() // &lt;--- asCreationExtras: convert a builder back to `CreationExtras` as needed.\n</code></pre> <p>More details: with Kotlin 1.9.20, an expect with default arguments are no longer permitted when an actual is a typealias (see KT-57614), we cannot use <code>actual typealias MutableCreationExtras = androidx.lifecycle.viewmodel.MutableCreationExtras</code>. So we have to use wrapper class instead.</p> </li> </ul> <ul> <li>Update the docs of <code>ViewModel.viewModelScope</code> to clarify that the scope is thread-safe   on both Android and non-Android targets.</li> </ul> <ul> <li>On non-Android targets<ul> <li><code>ViewModel.clear()</code> method has been refactored to improve the performance.</li> <li>Any <code>Exception</code> thrown from <code>Closeable.close()</code> will be re-thrown as <code>RuntimeException</code>.</li> </ul> </li> </ul>"},{"location":"changelog/#050-sep-27-2023","title":"0.5.0 - Sep 27, 2023","text":""},{"location":"changelog/#update-dependencies_1","title":"Update dependencies","text":"<ul> <li>Kotlin <code>1.9.0</code>.</li> <li>AndroidX Lifecycle <code>2.6.1</code>.</li> <li>KotlinX Coroutines <code>1.7.3</code>.</li> <li>Android Gradle Plugin <code>8.1.0</code>.</li> </ul>"},{"location":"changelog/#viewmodel_2","title":"viewmodel","text":"<ul> <li>Add <code>ViewModelStore</code> and <code>ViewModelStoreOwner</code>.</li> <li>Add <code>ViewModelFactory</code> and <code>VIEW_MODEL_KEY</code>.</li> <li>Add <code>CreationExtras</code> and <code>CreationExtrasKey</code>.</li> <li>Add <code>buildCreationExtras</code> and <code>CreationExtras.edit</code>.</li> <li>Add <code>ViewModel.isCleared()</code> method to check if the <code>ViewModel</code> is cleared, only available on   non-Android targets.</li> <li>Add <code>MainThread</code> (moved from <code>viewmodel-savedstate</code> module).</li> </ul>"},{"location":"changelog/#viewmodel-savedstate","title":"viewmodel-savedstate","text":"<ul> <li>Remove <code>MainThread</code> (moved to <code>viewmodel</code> module).</li> <li>Add <code>SavedStateHandleFactory</code> interface.</li> <li>Add <code>SAVED_STATE_HANDLE_FACTORY_KEY</code> and <code>CreationExtras.createSavedStateHandle()</code>.</li> </ul>"},{"location":"changelog/#viewmodel-compose","title":"viewmodel-compose","text":"<ul> <li>A new module allows to access <code>ViewModel</code>s in Jetpack Compose Multiplatform.<ul> <li><code>kmpViewModel</code> to retrieve <code>ViewModel</code>s in @Composable functions.</li> <li><code>LocalSavedStateHandleFactory</code> and <code>SavedStateHandleFactoryProvider</code> to   get/provide <code>SavedStateHandleFactory</code> in @Composable functions.   It allows integration with any navigation library.</li> <li><code>LocalViewModelStoreOwner</code> and <code>ViewModelStoreOwnerProvider</code> to   get/provide <code>ViewModelStoreOwner</code> in @Composable functions.   It allows integration with any navigation library.</li> <li><code>defaultPlatformCreationExtras</code> and <code>defaultPlatformViewModelStoreOwner</code>   to get the default <code>CreationExtras</code> and <code>ViewModelStoreOwner</code>,   which depends on the platform.</li> </ul> </li> </ul> <ul> <li>Dependencies: Compose Multiplatform 1.5.0.</li> </ul> <ul> <li>Docs: 0.x Viewmodel-Compose docs.</li> </ul>"},{"location":"changelog/#example-docs-and-tests","title":"Example, docs and tests","text":"<ul> <li>Refactor example code.</li> </ul> <ul> <li>Add Compose Multiplatform sample which shares <code>ViewModel</code>s and integrates with <code>Navigation</code> in Compose Multiplatform.</li> </ul> <ul> <li>Add Compose Multiplatform KmpViewModel KMM Unsplash Sample, a KMP template of the Unsplash App using Compose multiplatform for Android, Desktop, iOS. Share everything including data, domain, presentation, and UI.</li> </ul> <ul> <li>Add more docs: 0.x docs.</li> <li>Add more tests.</li> </ul>"},{"location":"changelog/#040-apr-7-2023","title":"0.4.0 - Apr 7, 2023","text":""},{"location":"changelog/#changed","title":"Changed","text":""},{"location":"changelog/#update-dependencies_2","title":"Update dependencies","text":"<ul> <li>Kotlin <code>1.8.10</code>.</li> <li>Target <code>Java 11</code>.</li> <li>Touchlab Stately <code>1.2.5</code>.</li> <li>AndroidX Lifecycle <code>2.6.0</code>.</li> <li>Android Gradle Plugin <code>7.4.2</code>.</li> </ul>"},{"location":"changelog/#flow-wrappers","title":"Flow wrappers","text":"<ul> <li>Add <code>NonNullStateFlowWrapper</code> and <code>NullableFlowWrapper</code> to common source set.</li> </ul> <ul> <li>Move all <code>Flow</code> wrappers to common source set.   Previously, they were only available for <code>Darwin targets</code> (<code>iOS</code>, <code>macOS</code>, <code>tvOS</code>, <code>watchOS</code>).</li> </ul> <ul> <li> <p>Add <code>Flow.wrap()</code> extension methods to wrap <code>Flow</code>s sources:</p> <ul> <li><code>Flow&lt;T: Any&gt;.wrap(): NonNullFlowWrapper&lt;T&gt;</code>.</li> <li><code>Flow&lt;T&gt;.wrap(): NullableFlowWrapper&lt;T&gt;</code>.</li> <li><code>StateFlow&lt;T: Any&gt;.wrap(): NonNullStateFlowWrapper&lt;T&gt;</code>.</li> <li><code>StateFlow&lt;T&gt;.wrap(): NullableStateFlowWrapper&lt;T&gt;</code>.</li> </ul> <p>In common code, you can use these methods to wrap <code>Flow</code> sources and use them in Swift code easily. <pre><code>// Kotlin code\ndata class State(...)\n\nclass SharedViewModel : ViewModel() {\n  private val _state = MutableStateFlow(State(...))\n  val stateFlow: NonNullStateFlowWrapper&lt;State&gt; = _state.wrap()\n}\n</code></pre> <pre><code>// Swift code\n@MainActor class IosViewModel: ObservableObject {\n  private let vm: SharedViewModel\n\n  @Published private(set) var state: State\n\n  init(viewModel: SharedViewModel) {\n    vm = viewModel\n\n    state = vm.stateFlow.value       //  &lt;--- Use `value` property with type safety (do not need to cast).\n    vm.stateFlow.subscribe(          //  &lt;--- Use `subscribe(scope:onValue:)` method directly.\n      scope: vm.viewModelScope,\n      onValue: { [weak self] in self?.state = $0 }\n    )\n  }\n\n  deinit { vm.clear() }\n}\n</code></pre></p> </li> </ul>"},{"location":"changelog/#example-docs-and-tests_1","title":"Example, docs and tests","text":"<ul> <li>Refactor example code.</li> <li>Add more docs: 0.x docs.</li> <li>Add more tests.</li> </ul>"},{"location":"changelog/#030-mar-18-2023","title":"0.3.0 - Mar 18, 2023","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Add <code>NonNullFlowWrapper</code> and <code>NullableFlowWrapper</code>, that are wrappers for <code>Flow</code>s   that provides a more convenient API for subscribing to the <code>Flow</code>s on <code>Darwin targets</code> (<code>iOS</code>   , <code>macOS</code>, <code>tvOS</code>, <code>watchOS</code>)   <pre><code>// Kotlin code\nval flow: StateFlow&lt;Int&gt;\n</code></pre> <pre><code>// Swift code\nNonNullFlowWrapper&lt;KotlinInt&gt;(flow: flow).subscribe(\n  scope: scope,\n  onValue: { print(\"Received \", $0) }\n)\n</code></pre></li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Add more example, refactor example code.</li> <li>Add more docs: 0.x docs.</li> <li>Add more tests.</li> <li>Gradle <code>8.0.2</code>.</li> <li>Dokka <code>1.8.10</code>.</li> </ul>"},{"location":"changelog/#020-mar-5-2023","title":"0.2.0 - Mar 5, 2023","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li> <p>Add <code>kmp-viewmodel-savedstate</code> artifact. This artifact brings:</p> <ul> <li>Android Parcelable interface.</li> <li>The <code>@Parcelize</code> annotation   from kotlin-parcelize compiler plugin.</li> <li>SavedStateHandle   class.</li> </ul> <p>to Kotlin Multiplatform, so they can be used in common code. This is typically used for state/data preservation over Android configuration changes and system-initiated process death , when writing common code targeting Android.</p> </li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Add more example, refactor example code.</li> <li>Add more docs: 0.x docs.</li> </ul>"},{"location":"changelog/#010-feb-18-2023","title":"0.1.0 - Feb 18, 2023","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Make <code>ViewModel.viewModelScope</code> public.</li> </ul>"},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Add an <code>ViewModel.addCloseable</code> API and a new constructor   overload <code>constructor(vararg closeables: Closeable)</code>,   that allow you to add one or more <code>Closeable</code> objects to the <code>ViewModel</code>   that will be closed when the <code>ViewModel</code> is cleared without requiring any manual work   in <code>onCleared()</code>.</li> </ul>"},{"location":"changelog/#001-feb-11-2023","title":"0.0.1 - Feb 11, 2023","text":"<ul> <li>Initial release.</li> </ul>"},{"location":"multiplatform/","title":"Multiplatform","text":""},{"location":"multiplatform/#supported-targets","title":"Supported targets","text":"<ul> <li><code>android</code>.</li> <li><code>jvm</code> (must add <code>kotlinx-coroutines-swing</code>/<code>kotlinx-coroutines-javafx</code> to your dependencies to   make sure <code>Dispatchers.Main</code> available).</li> </ul> <p>[!NOTE] If you are targeting <code>Desktop</code> and:   - not using <code>JetBrains Compose Multiplatform</code>, you should provide the dependency <code>org.jetbrains.kotlinx:kotlinx-coroutines-swing</code> or <code>org.jetbrains.kotlinx:kotlinx-coroutines-javafx</code>.   - using <code>JetBrains Compose Multiplatform</code>, you should provide <code>org.jetbrains.kotlinx:kotlinx-coroutines-swing</code>.</p> <p>Because the <code>ViewModel.viewModelScope</code> depends on <code>Dispatchers.Main</code> provided by that libraries on Desktop.</p> <ul> <li><code>js</code> (<code>IR</code>).</li> <li><code>Darwin</code> targets:<ul> <li><code>iosArm64</code>, <code>iosX64</code>, <code>iosSimulatorArm64</code>.</li> <li><code>watchosArm32</code>, <code>watchosArm64</code>, <code>watchosX64</code>, <code>watchosSimulatorArm64</code>.</li> <li><code>tvosX64</code>, <code>tvosSimulatorArm64</code>, <code>tvosArm64</code>.</li> <li><code>macosX64</code>, <code>macosArm64</code>.</li> </ul> </li> </ul>"},{"location":"swift-interop/","title":"Swift interop","text":""},{"location":"swift-interop/#kmp-viewmodel-and-swift-interoperability","title":"<code>kmp-viewmodel</code> and <code>Swift</code> interoperability","text":"<p><code>kmp-viewmodel</code> can be exported and used in <code>Swift</code> as usual, however there are few limitations.</p>"},{"location":"swift-interop/#exposing-kmp-viewmodel-sources-to-swift","title":"Exposing <code>kmp-viewmodel</code> sources to Swift","text":"<p>KotlinX Coroutines Flow are Kotlin interfaces with generic types. Since generics for interfaces are not exported to <code>Swift</code>, <code>kmp-viewmodel</code> provides <code>Flow</code> wrapper classes.</p> <p>You can wrap <code>Flow</code>s sources using corresponding <code>wrap()</code> extension functions:</p> <ul> <li><code>Flow&lt;T: Any&gt;.wrap(): NonNullFlowWrapper&lt;T&gt;</code></li> <li><code>Flow&lt;T&gt;.wrap(): NullableFlowWrapper&lt;T&gt;</code></li> <li><code>StateFlow&lt;T: Any&gt;.wrap(): NonNullStateFlowWrapper&lt;T&gt;</code></li> <li><code>StateFlow&lt;T&gt;.wrap(): NullableStateFlowWrapper&lt;T&gt;</code></li> </ul> <p>Example:</p> <pre><code>// Kotlin code\nclass SharedViewModel : ViewModel() {\n  private val _state = MutableStateFlow(State())\n  val stateFlow: NonNullStateFlowWrapper&lt;State&gt; = _state.wrap()\n}\n</code></pre>"},{"location":"swift-interop/#using-wrappers-in-swift","title":"Using wrappers in Swift","text":"<p>Flow wrappers can be used in Swift as usual:</p> <pre><code>// Swift code\nfunc foo() {\n  let viewModel = SharedViewModel()\n\n  val closable = viewModel.stateFlow.subscribe(\n    scope: viewModel.viewModelScope,\n    onValue: { state in\n      // do something with state\n    }\n  )\n\n  // At some point later\n  closable.close()\n}\n</code></pre> <p>If Kotlin Code does not wrap <code>Flow</code>s to <code>FlowWrapper</code>s, we can also wrap them in Swift code.</p> <pre><code>// Swift code\nlet nonNull = NonNullFlowWrapperKt.wrap(self) as! NonNullFlowWrapper&lt;T&gt;\nlet nullable = NullableFlowWrapperKt.wrap(self) as! NullableFlowWrapper&lt;T&gt;\n...\n</code></pre>"},{"location":"swift-interop/#combine-interop","title":"Combine interop","text":"<p>Please check kotlinxCoroutinesFlowExtensions.swift .</p>"},{"location":"swift-interop/#rxswift-interop","title":"RxSwift interop","text":"<p>Please check kotlinxCoroutinesFlow+RxSwift.swift.</p>"},{"location":"viewmodel-compose-navigation/","title":"ViewModel and Navigation for JetBrains Compose Multiplatform","text":"<p>For more information check out https://github.com/hoc081098/solivagant. Solivagant is a library that provides the Navigation for JetBrains Compose Multiplatform. It\u2019s pragmatic, type safety navigation and more\u2026</p>"},{"location":"viewmodel-compose/","title":"ViewModel Compose Multiplatform","text":""},{"location":"viewmodel-compose/#1-add-dependency","title":"1. Add dependency","text":"<ul> <li>Add <code>mavenCentral()</code> to <code>repositories</code> list in <code>build.gradle.kts</code>/<code>settings.gradle.kts</code>.</li> </ul> <pre><code>// settings.gradle.kts\ndependencyResolutionManagement {\n  [...]\n  repositories {\n    mavenCentral()\n    [...]\n  }\n}\n</code></pre> <ul> <li>Add dependency to <code>build.gradle.kts</code> of your shared module.</li> </ul> <pre><code>// build.gradle.kts\nkotlin {\n  sourceSets {\n    val commonMain by getting {\n      dependencies {\n        api(\"io.github.hoc081098:kmp-viewmodel-compose:0.6.1\")\n      }\n    }\n  }\n}\n</code></pre> Snapshots of the development version are available in Sonatype's snapshots repository. <p> <pre><code>// settings.gradle.kts\ndependencyResolutionManagement {\n  repositoriesMode.set(RepositoriesMode.PREFER_PROJECT)\n  repositories {\n    maven(url = \"https://s01.oss.sonatype.org/content/repositories/snapshots/\")\n    [...]\n  }\n}\n\n// build.gradle.kts\ndependencies {\n  api(\"io.github.hoc081098:kmp-viewmodel-compose:0.6.2-SNAPSHOT\")\n}\n</code></pre> </p>"},{"location":"viewmodel-compose/#2-create-your-viewmodel-in-commonmain-source-set","title":"2. Create your <code>ViewModel</code> in <code>commonMain</code> source set","text":"<pre><code>class ScreenAViewModel(\n  private val savedStateHandle: SavedStateHandle,\n) : ViewModel() {\n  val countStateFlow = savedStateHandle.getStateFlow(\"count\", 0)\n\n  init {\n    println(\"$this init\")\n\n    addCloseable {\n      println(\"$this close\")\n    }\n  }\n\n  fun inc() {\n    savedStateHandle[\"count\"] = countStateFlow.value + 1\n  }\n}\n</code></pre>"},{"location":"viewmodel-compose/#3-use-viewmodel-in-compose-multiplatform","title":"3. Use <code>ViewModel</code> in Compose Multiplatform","text":"<p>Using <code>kmpViewModel</code> to retrieve <code>ViewModel</code> in <code>@Composable</code> functions.</p> <pre><code>@Composable\nfun ScreenAContent(\n  viewModel: ScreenAViewModel = kmpViewModel(\n    factory = viewModelFactory {\n      ScreenAViewModel(savedStateHandle = createSavedStateHandle())\n    },\n  ),\n  modifier: Modifier = Modifier,\n) {\n  val count by viewModel.countStateFlow.collectAsState()\n\n  Column(\n    modifier = modifier.fillMaxSize(),\n    verticalArrangement = Arrangement.Center,\n    horizontalAlignment = Alignment.CenterHorizontally,\n  ) {\n    Text(text = \"Count: $count\")\n\n    Spacer(modifier = Modifier.height(16.dp))\n\n    Button(onClick = viewModel::inc) {\n      Text(text = \"Increment\")\n    }\n  }\n}\n</code></pre>"},{"location":"viewmodel-compose/#4-customize-savedstatehandlefactory-and-viewmodelstoreowner","title":"4. Customize <code>SavedStateHandleFactory</code> and <code>ViewModelStoreOwner</code>","text":"<p><code>LocalSavedStateHandleFactory</code> and <code>LocalViewModelStoreOwner</code> are used to easily provide <code>SavedStateHandleFactory</code> and <code>ViewModelStoreOwner</code> in <code>@Composable</code> functions. It allows integration with any navigation library.</p> <pre><code>// https://github.com/hoc081098/kmp-viewmodel/blob/892cbe109fe623c57d3769b830ffda198159aee4/standalone-sample/kmpviewmodel_compose_sample/common/src/commonMain/kotlin/com/hoc081098/common/navigation/NavHost.kt#L123\n\n@Composable\nprivate fun &lt;T : Route&gt; NavEntryContent(\n  navEntry: NavEntry&lt;T&gt;,\n  navStoreViewModel: NavStoreViewModel,\n) {\n  ViewModelStoreOwnerProvider(\n    navStoreViewModel provideViewModelStoreOwner navEntry.id,\n  ) {\n    SavedStateHandleFactoryProvider(\n      navStoreViewModel provideSavedStateHandleFactory navEntry,\n    ) {\n      navEntry.content.Content(route = navEntry.route)\n    }\n  }\n}\n</code></pre> <p>Full example is available at: https://github.com/hoc081098/kmp-viewmodel/blob/892cbe109fe623c57d3769b830ffda198159aee4/standalone-sample/kmpviewmodel_compose_sample/common/src/commonMain/kotlin/com/hoc081098/common/navigation/NavHost.kt#L123</p>"},{"location":"viewmodel-compose/#5-navigation-for-compose-multiplatform","title":"5. Navigation for Compose Multiplatform","text":"<p>Check out https://github.com/hoc081098/solivagant</p>"},{"location":"viewmodel-koin-compose/","title":"ViewModel Compose Multiplatform and Koin","text":"<p>Koin integration with Kotlin Multiplatform ViewModel and Jetpack Compose Multiplatform.</p> <p>Koin is the pragmatic Kotlin &amp; Kotlin Multiplatform Dependency Injection framework. For more information check out the Koin documentation.</p> <p>The <code>kmp-viewmodel-koin-compose</code> library provides the integration of <code>kmp-viewmodel-compose</code> and <code>Koin</code>, helps us to retrieve <code>ViewModel</code> in <code>@Composable</code> functions from the Koin DI container without manually dependency injection.</p>"},{"location":"viewmodel-koin-compose/#1-add-dependency","title":"1. Add dependency","text":"<ul> <li>Add <code>mavenCentral()</code> to <code>repositories</code> list in <code>build.gradle.kts</code>/<code>settings.gradle.kts</code>.</li> </ul> <pre><code>// settings.gradle.kts\ndependencyResolutionManagement {\n  [...]\n  repositories {\n    mavenCentral()\n    [...]\n  }\n}\n</code></pre> <ul> <li>Add dependency to <code>build.gradle.kts</code> of your shared module.</li> </ul> <pre><code>// build.gradle.kts\nkotlin {\n  sourceSets {\n    val commonMain by getting {\n      dependencies {\n        api(\"io.github.hoc081098:kmp-viewmodel-koin-compose:0.6.1\")\n      }\n    }\n  }\n}\n</code></pre> Snapshots of the development version are available in Sonatype's snapshots repository. <p> <pre><code>// settings.gradle.kts\ndependencyResolutionManagement {\n  repositoriesMode.set(RepositoriesMode.PREFER_PROJECT)\n  repositories {\n    maven(url = \"https://s01.oss.sonatype.org/content/repositories/snapshots/\")\n    [...]\n  }\n}\n\n// build.gradle.kts\ndependencies {\n  api(\"io.github.hoc081098:kmp-viewmodel-koin-compose:0.6.2-SNAPSHOT\")\n}\n</code></pre> </p>"},{"location":"viewmodel-koin-compose/#2-declare-viewmodel-in-a-koin-module-using-factory-or-factoryof","title":"2. Declare <code>ViewModel</code> in a Koin Module using <code>factory</code> or <code>factoryOf</code>","text":"<pre><code>import com.hoc081098.kmp.viewmodel.ViewModel\nimport org.koin.core.module.Module\nimport org.koin.core.module.dsl.factoryOf\nimport org.koin.dsl.module\n\nclass MyRepository\n\nclass MyViewModel(\n  val myRepository: MyRepository,\n  val savedStateHandle: SavedStateHandle,\n  val id: Int,\n) : ViewModel() {\n  // ...\n}\n\nval myModule: Module = module {\n  factoryOf(::MyRepository)\n  factoryOf(::MyViewModel)\n}\n</code></pre> <p>[!NOTE] Make sure to include your module definition in the Koin DI container, for example:</p> <p><pre><code>startKoin {\n  // others ...\n  modules(myModule)\n}\n</code></pre> For more information check out the Start Koin documentation.</p>"},{"location":"viewmodel-koin-compose/#3-retrieve-viewmodel-in-composables-function-via-koinkmpviewmodel-function","title":"3. Retrieve <code>ViewModel</code> in <code>@Composable</code>s function via <code>koinKmpViewModel</code> function","text":"<pre><code>import org.koin.core.parameter.parametersOf\nimport com.hoc081098.kmp.viewmodel.koin.compose.koinKmpViewModel\n\n@Composable\nfun MyScreen(\n  id: Int,\n  viewModel: MyViewModel = koinKmpViewModel(\n    key = \"MyViewModel-$id\",\n    parameters = { parametersOf(id) }\n  )\n) {\n  // ...\n}\n</code></pre>"},{"location":"viewmodel-savedstate-safe/","title":"Type-safe access to SavedStateHandle","text":"<ul> <li>Module <code>kmp-viewmodel-savedstate</code> provides the type-safe API   that allows you to access <code>SavedStateHandle</code> in a type-safe way.</li> </ul> <ul> <li>All API are available on all platforms and are located in the <code>com.hoc081098.kmp.viewmodel.safe</code>   package.</li> </ul> <ul> <li> <p>There are 2 types of keys:</p> <ul> <li><code>NonNullSavedStateHandleKey&lt;T&gt;</code>: key for values stored in <code>SavedStateHandle</code>.   The type of the value associated with this key is <code>T</code> (non-null).</li> <li><code>NullableSavedStateHandleKey&lt;T&gt;</code>: key for values stored in <code>SavedStateHandle</code>.   The type of the value associated with this key is <code>T?</code> (nullable, <code>null</code> is valid).</li> </ul> </li> </ul> <ul> <li>Using <code>SavedStateHandle.safe</code> extension function to access <code>SavedStateHandle</code> in a type-safe way.   It accepts a lambda with a single parameter of type <code>SafeSavedStateHandle</code>.   <code>SafeSavedStateHandle</code> provides methods:<ul> <li><code>public inline operator fun &lt;T : Any&gt; get(key: NonNullSavedStateHandleKey&lt;T&gt;): T</code>.</li> <li><code>public inline operator fun &lt;T : Any&gt; get(key: NullableSavedStateHandleKey&lt;T&gt;): T?</code>.</li> <li><code>public inline operator fun &lt;T : Any&gt; set(key: NonNullSavedStateHandleKey&lt;T&gt;, value: T): Unit</code>.</li> <li><code>public inline operator fun &lt;T : Any&gt; set(key: NullableSavedStateHandleKey&lt;T&gt;, value: T?): Unit</code>.</li> <li><code>public inline fun &lt;T : Any&gt; getStateFlow(key: NonNullSavedStateHandleKey&lt;T&gt;): StateFlow&lt;T&gt;</code>.</li> <li><code>public inline fun &lt;T : Any&gt; getStateFlow(key: NullableSavedStateHandleKey&lt;T&gt;): StateFlow&lt;T?&gt;</code>.</li> <li><code>public inline fun &lt;T : Any&gt; remove(key: NullableSavedStateHandleKey&lt;T&gt;)</code>.</li> </ul> </li> </ul>"},{"location":"viewmodel-savedstate-safe/#1-define-your-savedstatehandle-keys","title":"1. Define your <code>SavedStateHandle</code> keys","text":"<pre><code>import com.hoc081098.kmp.viewmodel.safe.NonNullSavedStateHandleKey\nimport com.hoc081098.kmp.viewmodel.safe.string\n\nprivate val searchTermKey: NonNullSavedStateHandleKey&lt;String&gt; = NonNullSavedStateHandleKey.string(\n  key = \"search_term\",\n  defaultValue = \"\"\n)\nprivate val userIdKey: NullableSavedStateHandleKey&lt;String&gt; = NullableSavedStateHandleKey.string(\"user_id\")\n</code></pre>"},{"location":"viewmodel-savedstate-safe/#2-use-savedstatehandlesafe-extension-function","title":"2. Use <code>SavedStateHandle.safe</code> extension function","text":"<pre><code>import com.hoc081098.kmp.viewmodel.SavedStateHandle\nimport com.hoc081098.kmp.viewmodel.ViewModel\nimport com.hoc081098.kmp.viewmodel.safe.NonNullSavedStateHandleKey\nimport com.hoc081098.kmp.viewmodel.safe.NullableSavedStateHandleKey\nimport com.hoc081098.kmp.viewmodel.safe.safe\nimport com.hoc081098.kmp.viewmodel.safe.string\nimport com.hoc081098.kmp.viewmodel.wrapper.NonNullStateFlowWrapper\nimport com.hoc081098.kmp.viewmodel.wrapper.NullableStateFlowWrapper\nimport com.hoc081098.kmp.viewmodel.wrapper.wrap\n\nclass SearchViewModel(\n  private val savedStateHandle: SavedStateHandle,\n) : ViewModel() {\n  internal val searchTermStateFlow: NonNullStateFlowWrapper&lt;String&gt; = savedStateHandle\n    .safe { it.getStateFlow(searchTermKey) }\n    .wrap()\n\n  internal val userIdStateFlow: NullableStateFlowWrapper&lt;String?&gt; = savedStateHandle\n    .safe { it.getStateFlow(userIdKey) }\n    .wrap()\n\n  internal fun changeSearchTerm(searchTerm: String) {\n    savedStateHandle.safe { it[searchTermKey] = searchTerm }\n  }\n\n  private fun setUserId(userId: String?) = savedStateHandle.safe { it[userIdKey] = userId }\n\n  companion object {\n    private val searchTermKey: NonNullSavedStateHandleKey&lt;String&gt; = NonNullSavedStateHandleKey.string(\n      key = \"search_term\",\n      defaultValue = \"\",\n    )\n    private val userIdKey: NullableSavedStateHandleKey&lt;String&gt; = NullableSavedStateHandleKey.string(\"user_id\")\n  }\n}\n</code></pre>"},{"location":"viewmodel-savedstate/","title":"ViewModel SavedState","text":"<p>This library brings:</p> <ul> <li>Android Parcelable interface.</li> <li>The <code>@Parcelize</code> annotation   from kotlin-parcelize compiler plugin.</li> <li>SavedStateHandle   class.</li> </ul> <p>to Kotlin Multiplatform, so they can be used in common code. This is typically used for state/data preservation over Android configuration changes and system-initiated process death , when writing common code targeting Android.</p>"},{"location":"viewmodel-savedstate/#1-add-dependency","title":"1. Add dependency","text":"<ul> <li>Add <code>mavenCentral()</code> to <code>repositories</code> list in <code>build.gradle.kts</code>/<code>settings.gradle.kts</code>.</li> </ul> <pre><code>// settings.gradle.kts\ndependencyResolutionManagement {\n  [...]\n  repositories {\n    mavenCentral()\n    [...]\n  }\n}\n</code></pre> <ul> <li>Add dependency to <code>build.gradle.kts</code> of your shared module (must use <code>api</code> configuration).</li> </ul> <pre><code>// build.gradle.kts\nkotlin {\n  sourceSets {\n    val commonMain by getting {\n      dependencies {\n        api(\"io.github.hoc081098:kmp-viewmodel-savedstate:0.6.1\")\n      }\n    }\n  }\n}\n</code></pre> <ul> <li>Expose <code>kmp-viewmodel-savedstate</code> to <code>Darwin</code> native side.</li> </ul> <pre><code>// Cocoapods\nkotlin {\n  cocoapods {\n    [...]\n    framework {\n      baseName = \"shared\"\n      export(\"io.github.hoc081098:kmp-viewmodel-savedstate:0.6.1\") // required to expose the classes to iOS.\n    }\n  }\n}\n\n// -- OR --\n\n// Kotlin/Native as an Apple framework\nkotlin {\n  ios {\n    binaries {\n      framework {\n        baseName = \"shared\"\n        export(\"io.github.hoc081098:kmp-viewmodel-savedstate:0.6.1\") // required to expose the classes to iOS.\n      }\n    }\n  }\n}\n</code></pre> <ul> <li>Optional: apply <code>kotlin-parcelize</code> if you want to use <code>@Parcelize</code> annotation to   generate <code>Parcelable</code> implementation for Android.</li> </ul> <pre><code>// build.gradle.kts\nplugins {\n  id(\"kotlin-parcelize\") // Apply the plugin for Android\n}\n</code></pre> Snapshots of the development version are available in Sonatype's snapshots repository. <p> <pre><code>// settings.gradle.kts\ndependencyResolutionManagement {\n  repositoriesMode.set(RepositoriesMode.PREFER_PROJECT)\n  repositories {\n    maven(url = \"https://s01.oss.sonatype.org/content/repositories/snapshots/\")\n    [...]\n  }\n}\n\n// build.gradle.kts\ndependencies {\n  api(\"io.github.hoc081098:kmp-viewmodel-savedstate:0.6.2-SNAPSHOT\")\n}\n</code></pre> </p>"},{"location":"viewmodel-savedstate/#2-overview","title":"2. Overview","text":"<pre><code>public expect class SavedStateHandle {\n  public constructor(initialState: Map&lt;String, Any?&gt;)\n  public constructor()\n\n  public operator fun contains(key: String): Boolean\n  public operator fun &lt;T&gt; get(key: String): T?\n  public fun &lt;T&gt; getStateFlow(key: String, initialValue: T): StateFlow&lt;T&gt;\n  public fun keys(): Set&lt;String&gt;\n\n  public fun &lt;T&gt; remove(key: String): T?\n  public operator fun &lt;T&gt; set(key: String, value: T?): Unit\n}\n</code></pre> <p>The <code>SavedStateHandle</code> class provides some methods to get and set data. On Android, it is a type alias of <code>androidx.lifecycle.SavedStateHandle</code>. On other platforms, it is simply a wrapper of the normal <code>Map&lt;String, Any?&gt;</code>.</p> <p>Because the limitation of Android platform, the data stored in <code>SavedStateHandle</code> must be one of the following types:</p> Type/Class support Array support double double[] int int[] long long[] String String[] byte byte[] char char[] CharSequence CharSequence[] float float[] Parcelable Parcelable[] Serializable Serializable[] short short[] SparseArray Binder Bundle ArrayList Size (only in API 21+) SizeF (only in API 21+) <p>If the class does not extend one of those in the above list, consider making the class parcelable by adding the <code>@Parcelize</code> annotation. See SavedStateHandle supported types docs for more details.</p>"},{"location":"viewmodel-savedstate/#3-usage-example","title":"3. Usage example","text":""},{"location":"viewmodel-savedstate/#31-kotlin-common-code","title":"3.1. Kotlin common code","text":"<pre><code>import com.hoc081098.kmp.viewmodel.SavedStateHandle\nimport com.hoc081098.kmp.viewmodel.ViewModel\nimport com.hoc081098.kmp.viewmodel.parcelable.Parcelable\nimport com.hoc081098.kmp.viewmodel.parcelable.Parcelize\n\n@Parcelize\ndata class User(val id: Long, val name: String) : Parcelable\n\nclass UserViewModel(\n  private val savedStateHandle: SavedStateHandle,\n  private val getUserUseCase: suspend () -&gt; User?,\n) : ViewModel() {\n  val userStateFlow = savedStateHandle.getStateFlow&lt;User?&gt;(USER_KEY, null).wrap()\n\n  fun getUser() {\n    viewModelScope.launch {\n      try {\n        val user = getUserUseCase()\n        savedStateHandle[USER_KEY] = user\n      } catch (e: CancellationException) {\n        throw e\n      } catch (@Suppress(\"TooGenericExceptionCaught\") e: Exception) {\n        e.printStackTrace()\n      }\n    }\n  }\n\n  private companion object {\n    private const val USER_KEY = \"user_key\"\n  }\n}\n</code></pre>"},{"location":"viewmodel-savedstate/#32-darwin-targets-swift-code","title":"3.2. Darwin targets (Swift code)","text":"<pre><code>import Foundation\nimport Combine\nimport shared\n\nprivate actor FakeGetUserUseCaseActor {\n  private var count = 0\n\n  func call() async throws -&gt; User? {\n    try await Task.sleep(nanoseconds: 1 * 1_000_000_000)\n\n    self.count += 1\n    if self.count.isMultiple(of: 2) {\n      return nil\n    } else {\n      return User(id: Int64(count), name: \"hoc081098\")\n    }\n  }\n}\n\nprivate class FakeGetUserUseCase: KotlinSuspendFunction0 {\n  private let actor = FakeGetUserUseCaseActor()\n\n  func invoke() async throws -&gt; Any? { try await self.`actor`.call() }\n}\n\n@MainActor\nclass IosUserViewModel: ObservableObject {\n  private let commonVm: UserViewModel = UserViewModel.init(\n    savedStateHandle: .init(),\n    getUserUseCase: FakeGetUserUseCase()\n  )\n\n  @Published private(set) var user: User?\n\n  init() {\n    self.commonVm.userStateFlow.subscribe(\n      scope: self.commonVm.viewModelScope,\n      onValue: { [weak self] in self?.user = $0 }\n    )\n  }\n\n  func getUser() { self.commonVm.getUser() }\n\n  deinit {\n    self.commonVm.clear()\n  }\n}\n</code></pre> <p>For more details, please check kmp viewmodel sample.</p>"},{"location":"viewmodel-savedstate/#4-type-safe-access","title":"4. Type-safe access","text":"<p>Please check Type-safe access to SavedStateHandle for more details.</p>"},{"location":"viewmodel/","title":"ViewModel","text":""},{"location":"viewmodel/#1-add-dependency","title":"1. Add dependency","text":"<ul> <li>Add <code>mavenCentral()</code> to <code>repositories</code> list in <code>build.gradle.kts</code>/<code>settings.gradle.kts</code>.</li> </ul> <pre><code>// settings.gradle.kts\ndependencyResolutionManagement {\n  [...]\n  repositories {\n    mavenCentral()\n    [...]\n  }\n}\n</code></pre> <ul> <li>Add dependency to <code>build.gradle.kts</code> of your shared module (must use <code>api</code> configuration).</li> </ul> <pre><code>// build.gradle.kts\nkotlin {\n  sourceSets {\n    val commonMain by getting {\n      dependencies {\n        api(\"io.github.hoc081098:kmp-viewmodel:0.6.1\")\n      }\n    }\n  }\n}\n</code></pre> <ul> <li>Expose <code>kmp-viewmodel</code> to <code>Darwin</code> native side.</li> </ul> <pre><code>// Cocoapods\nkotlin {\n  cocoapods {\n    [...]\n    framework {\n      baseName = \"shared\"\n      export(\"io.github.hoc081098:kmp-viewmodel:0.6.1\") // required to expose the classes to iOS.\n    }\n  }\n}\n\n// -- OR --\n\n// Kotlin/Native as an Apple framework\nkotlin {\n  ios {\n    binaries {\n      framework {\n        baseName = \"shared\"\n        export(\"io.github.hoc081098:kmp-viewmodel:0.6.1\") // required to expose the classes to iOS.\n      }\n    }\n  }\n}\n</code></pre> Snapshots of the development version are available in Sonatype's snapshots repository. <p> <pre><code>// settings.gradle.kts\ndependencyResolutionManagement {\n  repositoriesMode.set(RepositoriesMode.PREFER_PROJECT)\n  repositories {\n    maven(url = \"https://s01.oss.sonatype.org/content/repositories/snapshots/\")\n    [...]\n  }\n}\n\n// build.gradle.kts\ndependencies {\n  api(\"io.github.hoc081098:kmp-viewmodel:0.6.2-SNAPSHOT\")\n}\n</code></pre> </p>"},{"location":"viewmodel/#2-overview","title":"2. Overview","text":"<pre><code>public expect abstract class ViewModel {\n  public constructor()\n  public constructor(vararg closeables: Closeable)\n\n  public val viewModelScope: CoroutineScope\n  public fun addCloseable(closeable: Closeable)\n\n  protected open fun onCleared()\n}\n</code></pre> <ul> <li>The ViewModel has a <code>viewModelScope</code> which is a <code>CoroutineScope</code> that is cancelled when the   ViewModel   is cleared. Once the ViewModel is cleared, all coroutines launched in this scope will be   cancelled.</li> </ul> <ul> <li><code>addCloseable</code> method is used to add <code>Closeable</code> that will be closed directly before <code>onCleared</code>   is called.</li> </ul> <ul> <li><code>onCleared</code> is called when the ViewModel is cleared, you can override this method to do some clean   up work.   But it is recommended to use the <code>addCloseable</code> method instead of overriding <code>onCleared</code> method.</li> </ul>"},{"location":"viewmodel/#3-create-your-viewmodel-in-commonmain-source-set","title":"3. Create your <code>ViewModel</code> in <code>commonMain</code> source set.","text":"<pre><code>import com.hoc081098.kmp.viewmodel.Closeable\nimport com.hoc081098.kmp.viewmodel.ViewModel\nimport com.hoc081098.kmp.viewmodel.wrapper.NonNullFlowWrapper\nimport com.hoc081098.kmp.viewmodel.wrapper.NonNullStateFlowWrapper\nimport com.hoc081098.kmp.viewmodel.wrapper.wrap\n\nclass ProductsViewModel(\n  private val getProducts: GetProducts,\n) : ViewModel() {\n  private val _eventChannel = Channel&lt;ProductSingleEvent&gt;(Int.MAX_VALUE)\n  private val _actionFlow = MutableSharedFlow&lt;ProductsAction&gt;(Int.MAX_VALUE)\n\n  val stateFlow: NonNullStateFlowWrapper&lt;ProductsState&gt;\n  val eventFlow: NonNullFlowWrapper&lt;ProductSingleEvent&gt; = _eventChannel.receiveAsFlow().wrap()\n\n  init {\n    // Close _eventChannel when ViewModel is cleared.\n    addCloseable(_eventChannel::close)\n\n    stateFlow = _actionFlow\n      .transformToStateFlow()\n      .stateIn(\n        scope = viewModelScope,\n        started = SharingStarted.Eagerly,\n        initialValue = ProductsState.INITIAL,\n      )\n      .wrap()\n  }\n\n  // Do business logic here, to convert `ProductsAction`s to `ProductsState`s.\n  private fun SharedFlow&lt;ProductsAction&gt;.transformToStateFlow(): Flow&lt;ProductsState&gt; = TODO()\n\n  fun dispatch(action: ProductsAction) {\n    _actionFlow.tryEmit(action)\n  }\n}\n</code></pre>"},{"location":"viewmodel/#4-use-common-viewmodel-in-each-platform","title":"4. Use common <code>ViewModel</code> in each platform.","text":""},{"location":"viewmodel/#41-android","title":"4.1. Android","text":"<p>Use the <code>ViewModel</code> as a normal <code>AndroidX Lifecycle ViewModel</code>.</p> <pre><code>import androidx.lifecycle.viewmodel.compose.viewModel\n\n@Composable\nfun ProductsScreen(\n  viewModel: ProductsViewModel = viewModel(),\n) {\n  val state by viewModel.stateFlow.collectAsStateWithLifecycle()\n  // Render UI based on state.\n}\n</code></pre>"},{"location":"viewmodel/#42-non-android","title":"4.2. non-Android","text":"<ul> <li>Make sure that you call <code>clear()</code> on your ViewModel when it\u2019s no longer needed,   to properly cancel the <code>CoroutineScope</code> and close resources.   For example, you should call <code>clear()</code> in <code>deinit</code> block when using <code>ViewModel</code> in <code>Darwin</code>   targets (<code>ios</code>, <code>macos</code>, <code>tvos</code>, <code>watchos</code>).</li> </ul> <ul> <li>In addition, you should create a wrapper of the common <code>ViewModel</code> in each platform and use   flow wrappers provided by this library (<code>NonNullFlowWrapper</code>, <code>NullableFlowWrapper</code>   , <code>NonNullStateFlowWrapper</code>, <code>NullableStateFlowWrapper</code>), to consume   the common <code>ViewModel</code> easily and safely.</li> </ul> <p>For more details, please check kmp viewmodel sample.</p> <p>The below example is using <code>NonNullStateFlowWrapper.subscribe(scope:onValue:)</code> method to consume the <code>Flow</code>s in <code>Darwin</code> targets (Swift language).</p> <pre><code>@MainActor\nclass IosProductsViewModel: ObservableObject {\n  private let commonVm: ProductsViewModel\n\n  @Published private(set) var state: ProductsState\n\n  init(commonVm: ProductsViewModel) {\n    self.commonVm = commonVm\n\n    self.state = self.commonVm.stateFlow.value\n    self.commonVm.stateFlow.subscribe(\n      scope: self.commonVm.viewModelScope,\n      onValue: { [weak self] in self?.state = $0 } // use weak self to avoid retain cycle.\n    )\n  }\n\n  func dispatch(action: ProductsAction) { self.commonVm.dispatch(action: action) }\n\n  deinit { self.commonVm.clear() }\n}\n</code></pre>"}]}