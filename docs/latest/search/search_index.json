{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kmp-viewmodel \ud83d\udd06","text":""},{"location":"#kotlin-multiplatform-viewmodel-kotlin-multiplatform-mvvm-compose-multiplatform-viewmodel","title":"Kotlin Multiplatform ViewModel - Kotlin Multiplatform MVVM - Compose Multiplatform ViewModel","text":"<p>Common/ Shared ViewModel in Kotlin Multiplatform - A Kotlin Multiplatform library that provides shared MVVM for UI applications. Components are lifecycle-aware on Android. Supports Android Parcelable, Kotlin Parcelize, AndroidX SavedStateHandle for restoring state after process death. Easy interoperability with Swift/Objective-C and SwiftUI. Supports Compose Multiplatform Framework (Android, Desktop, Web, iOS, macOS, tvOS, watchOS).</p> <p>The ViewModel class is a business logic or screen level state holder. It exposes state to the UI and encapsulates related business logic. Its principal advantage is that it caches state and persists it through configuration changes (on Android).</p> <p> </p> <p> </p>"},{"location":"#author-petrus-nguyen-thai-hoc","title":"Author: Petrus Nguy\u1ec5n Th\u00e1i H\u1ecdc","text":"<p>Liked some of my work? Buy me a coffee (or more likely a beer)</p> <p></p>"},{"location":"#supported-targets","title":"Supported targets","text":"<ul> <li><code>android</code>.</li> <li><code>jvm</code> (must add <code>kotlinx-coroutines-swing</code>/<code>kotlinx-coroutines-javafx</code> to your dependencies to   make sure <code>Dispatchers.Main</code> available).</li> <li><code>js</code> (<code>IR</code>).</li> <li><code>Darwin</code> targets:</li> <li><code>iosArm64</code>, <code>iosArm32</code>, <code>iosX64</code>, <code>iosSimulatorArm64</code>.</li> <li><code>watchosArm32</code>, <code>watchosArm64</code>, <code>watchosX64</code>, <code>watchosX86</code>, <code>watchosSimulatorArm64</code>.</li> <li><code>tvosX64</code>, <code>tvosSimulatorArm64</code>, <code>tvosArm64</code>.</li> <li><code>macosX64</code>, <code>macosArm64</code>.</li> </ul>"},{"location":"#docs","title":"Docs","text":""},{"location":"#latest-release-docs-httpshoc081098githubiokmp-viewmodeldocslatest","title":"latest release docs: https://hoc081098.github.io/kmp-viewmodel/docs/latest","text":""},{"location":"#snapshot-docs-httpshoc081098githubiokmp-viewmodeldocslatest","title":"Snapshot docs: https://hoc081098.github.io/kmp-viewmodel/docs/latest","text":""},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#1-kmp-viewmodel-library","title":"1. <code>kmp-viewmodel</code> library","text":"<p>For more information check out the docs.</p>"},{"location":"#2-kmp-viewmodel-savedstate-library","title":"2. <code>kmp-viewmodel-savedstate</code> library","text":"<p>For more information check out the docs.</p>"},{"location":"#3-kmp-viewmodel-and-swift-interoperability","title":"3. <code>kmp-viewmodel</code> and <code>Swift</code> interoperability","text":"<p>For more information check out the docs.</p>"},{"location":"#4-kmp-viewmodel-compose-library","title":"4. <code>kmp-viewmodel-compose</code> library","text":"<p>For more information check out the docs.</p>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li>[x] support <code>SaveStateHandle</code> (since 0.2.0).</li> <li>[x] add extensions for <code>Flow</code>/<code>StateFlow</code>, to use the ViewModel easily on <code>ios</code>/<code>macOS</code>/<code>tvOS</code>/<code>watchOS</code> platforms   (since 0.3.0).</li> <li>[ ] support <code>Compose Multiplatform Framework</code>.</li> </ul>"},{"location":"#license","title":"License","text":"<pre><code>MIT License\nCopyright (c) 2023 Petrus Nguy\u1ec5n Th\u00e1i H\u1ecdc\n</code></pre>"},{"location":"multiplatform/","title":"Multiplatform","text":""},{"location":"multiplatform/#supported-targets","title":"Supported targets","text":"<ul> <li><code>android</code>.</li> <li><code>jvm</code> (must add <code>kotlinx-coroutines-swing</code>/<code>kotlinx-coroutines-javafx</code> to your dependencies to   make sure <code>Dispatchers.Main</code> available).</li> <li><code>js</code> (<code>IR</code>).</li> <li><code>Darwin</code> targets:</li> <li><code>iosArm64</code>, <code>iosArm32</code>, <code>iosX64</code>, <code>iosSimulatorArm64</code>.</li> <li><code>watchosArm32</code>, <code>watchosArm64</code>, <code>watchosX64</code>, <code>watchosX86</code>, <code>watchosSimulatorArm64</code>.</li> <li><code>tvosX64</code>, <code>tvosSimulatorArm64</code>, <code>tvosArm64</code>.</li> <li><code>macosX64</code>, <code>macosArm64</code>.</li> </ul>"},{"location":"swift-interop/","title":"Swift Interop","text":""},{"location":"swift-interop/#kmp-viewmodel-and-swift-interoperability","title":"<code>kmp-viewmodel</code> and <code>Swift</code> interoperability","text":"<p><code>kmp-viewmodel</code> can be exported and used in <code>Swift</code> as usual, however there are few limitations.</p>"},{"location":"swift-interop/#exposing-kmp-viewmodel-sources-to-swift","title":"Exposing <code>kmp-viewmodel</code> sources to Swift","text":"<p>KotlinX Coroutines Flow are Kotlin interfaces with generic types. Since generics for interfaces are not exported to <code>Swift</code>, <code>kmp-viewmodel</code> provides <code>Flow</code> wrapper classes.</p> <p>You can wrap <code>Flow</code>s sources using corresponding <code>wrap()</code> extension functions:</p> <ul> <li><code>Flow&lt;T: Any&gt;.wrap(): NonNullFlowWrapper&lt;T&gt;</code></li> <li><code>Flow&lt;T&gt;.wrap(): NullableFlowWrapper&lt;T&gt;</code></li> <li><code>StateFlow&lt;T: Any&gt;.wrap(): NonNullStateFlowWrapper&lt;T&gt;</code></li> <li><code>StateFlow&lt;T&gt;.wrap(): NullableStateFlowWrapper&lt;T&gt;</code></li> </ul> <p>Example:</p> <pre><code>// Kotlin code\nclass SharedViewModel : ViewModel() {\nprivate val _state = MutableStateFlow(State())\nval stateFlow: NonNullStateFlowWrapper&lt;State&gt; = _state.wrap()\n}\n</code></pre>"},{"location":"swift-interop/#using-wrappers-in-swift","title":"Using wrappers in Swift","text":"<p>Flow wrappers can be used in Swift as usual:</p> <pre><code>// Swift code\nfunc foo() {\n  let viewModel = SharedViewModel()\n\n  val closable = viewModel.stateFlow.subscribe(\n    scope: viewModel.viewModelScope,\n    onValue: { state in\n      // do something with state\n    }\n  )\n\n  // At some point later\n  closable.close()\n}\n</code></pre> <p>If Kotlin Code does not wrap <code>Flow</code>s to <code>FlowWrapper</code>s, we can also wrap them in Swift code.</p> <pre><code>// Swift code\nlet nonNull = NonNullFlowWrapperKt.wrap(self) as! NonNullFlowWrapper&lt;T&gt;\nlet nullable = NullableFlowWrapperKt.wrap(self) as! NullableFlowWrapper&lt;T&gt;\n...\n</code></pre>"},{"location":"swift-interop/#combine-interop","title":"Combine interop","text":"<p>Please check kotlinxCoroutinesFlowExtensions.swift .</p>"},{"location":"swift-interop/#rxswift-interop","title":"RxSwift interop","text":"<p>Please check kotlinxCoroutinesFlow+RxSwift.swift.</p>"},{"location":"viewmodel-savedstate/","title":"Get started","text":"<p>This library brings:</p> <ul> <li>Android Parcelable interface.</li> <li>The <code>@Parcelize</code> annotation   from kotlin-parcelize compiler plugin.</li> <li>SavedStateHandle   class.</li> </ul> <p>to Kotlin Multiplatform, so they can be used in common code. This is typically used for state/data preservation over Android configuration changes and system-initiated process death , when writing common code targeting Android.</p>"},{"location":"viewmodel-savedstate/#1-add-dependency","title":"1. Add dependency","text":"<ul> <li>Add <code>mavenCentral()</code> to <code>repositories</code> list in <code>build.gradle.kts</code>/<code>settings.gradle.kts</code>.</li> </ul> <pre><code>// settings.gradle.kts\ndependencyResolutionManagement {\n[...]\nrepositories {\nmavenCentral()\n[...]\n}\n}\n</code></pre> <ul> <li>Add dependency to <code>build.gradle.kts</code> of your shared module (must use <code>api</code> configuration).</li> </ul> <pre><code>// build.gradle.kts\nkotlin {\nsourceSets {\nval commonMain by getting {\ndependencies {\napi(\"io.github.hoc081098:kmp-viewmodel-savedstate:0.4.0\")\n}\n}\n}\n}\n</code></pre> <ul> <li>Expose <code>kmp-viewmodel-savedstate</code> to <code>Darwin</code> native side.</li> </ul> <pre><code>// Cocoapods\nkotlin {\ncocoapods {\n[...]\nframework {\nbaseName = \"shared\"\nexport(\"io.github.hoc081098:kmp-viewmodel-savedstate:0.4.0\") // required to expose the classes to iOS.\n}\n}\n}\n\n// -- OR --\n\n// Kotlin/Native as an Apple framework\nkotlin {\nios {\nbinaries {\nframework {\nbaseName = \"shared\"\nexport(\"io.github.hoc081098:kmp-viewmodel-savedstate:0.4.0\") // required to expose the classes to iOS.\n}\n}\n}\n}\n</code></pre> <ul> <li>Optional: apply <code>kotlin-parcelize</code> if you want to use <code>@Parcelize</code> annotation to   generate <code>Parcelable</code> implementation for Android.</li> </ul> <pre><code>// build.gradle.kts\nplugins {\nid(\"kotlin-parcelize\") // Apply the plugin for Android\n}\n</code></pre> Snapshots of the development version are available in Sonatype's snapshots repository. <p> <pre><code>// settings.gradle.kts\ndependencyResolutionManagement {\nrepositoriesMode.set(RepositoriesMode.PREFER_PROJECT)\nrepositories {\nmaven(url = \"https://s01.oss.sonatype.org/content/repositories/snapshots/\")\n[...]\n}\n}\n\n// build.gradle.kts\ndependencies {\napi(\"io.github.hoc081098:kmp-viewmodel-savedstate:0.4.1-SNAPSHOT\")\n}\n</code></pre> </p>"},{"location":"viewmodel-savedstate/#2-overview","title":"2. Overview","text":"<pre><code>public expect class SavedStateHandle {\npublic constructor(initialState: Map&lt;String, Any?&gt;)\npublic constructor()\n\npublic operator fun contains(key: String): Boolean\npublic operator fun &lt;T&gt; get(key: String): T?\npublic fun &lt;T&gt; getStateFlow(key: String, initialValue: T): StateFlow&lt;T&gt;\npublic fun keys(): Set&lt;String&gt;\n\npublic fun &lt;T&gt; remove(key: String): T?\npublic operator fun &lt;T&gt; set(key: String, value: T?): Unit\n}\n</code></pre> <p>The <code>SavedStateHandle</code> class provides some methods to get and set data. On Android, it is a type alias of <code>androidx.lifecycle.SavedStateHandle</code>. On other platforms, it is simply a wrapper of the normal <code>Map&lt;String, Any?&gt;</code>.</p> <p>Because the limitation of Android platform, the data stored in <code>SavedStateHandle</code> must be one of the following types:</p> Type/Class support Array support double double[] int int[] long long[] String String[] byte byte[] char char[] CharSequence CharSequence[] float float[] Parcelable Parcelable[] Serializable Serializable[] short short[] SparseArray Binder Bundle ArrayList Size (only in API 21+) SizeF (only in API 21+) <p>If the class does not extend one of those in the above list, consider making the class parcelable by adding the <code>@Parcelize</code> annotation. See SavedStateHandle supported types docs for more details.</p>"},{"location":"viewmodel-savedstate/#3-usage-example","title":"3. Usage example","text":""},{"location":"viewmodel-savedstate/#31-kotlin-common-code","title":"3.1. Kotlin common code","text":"<pre><code>import com.hoc081098.kmp.viewmodel.SavedStateHandle\nimport com.hoc081098.kmp.viewmodel.ViewModel\nimport com.hoc081098.kmp.viewmodel.parcelable.Parcelable\nimport com.hoc081098.kmp.viewmodel.parcelable.Parcelize\n\n@Parcelize\ndata class User(val id: Long, val name: String) : Parcelable\n\nclass UserViewModel(\nprivate val savedStateHandle: SavedStateHandle,\nprivate val getUserUseCase: suspend () -&gt; User?,\n) : ViewModel() {\nval userStateFlow = savedStateHandle.getStateFlow&lt;User?&gt;(USER_KEY, null).wrap()\n\nfun getUser() {\nviewModelScope.launch {\ntry {\nval user = getUserUseCase()\nsavedStateHandle[USER_KEY] = user\n} catch (e: CancellationException) {\nthrow e\n} catch (@Suppress(\"TooGenericExceptionCaught\") e: Exception) {\ne.printStackTrace()\n}\n}\n}\n\nprivate companion object {\nprivate const val USER_KEY = \"user_key\"\n}\n}\n</code></pre>"},{"location":"viewmodel-savedstate/#32-darwin-targets-swift-code","title":"3.2. Darwin targets (Swift code)","text":"<pre><code>import Foundation\nimport Combine\nimport shared\n\nprivate actor FakeGetUserUseCaseActor {\n  private var count = 0\n\n  func call() async throws -&gt; User? {\n    try await Task.sleep(nanoseconds: 1 * 1_000_000_000)\n\n    self.count += 1\n    if self.count.isMultiple(of: 2) {\n      return nil\n    } else {\n      return User(id: Int64(count), name: \"hoc081098\")\n    }\n  }\n}\n\nprivate class FakeGetUserUseCase: KotlinSuspendFunction0 {\n  private let actor = FakeGetUserUseCaseActor()\n\n  func invoke() async throws -&gt; Any? { try await self.`actor`.call() }\n}\n\n@MainActor\nclass IosUserViewModel: ObservableObject {\n  private let commonVm: UserViewModel = UserViewModel.init(\n    savedStateHandle: .init(),\n    getUserUseCase: FakeGetUserUseCase()\n  )\n\n  @Published private(set) var user: User?\n\n  init() {\n    self.commonVm.userStateFlow.subscribe(\n      scope: self.commonVm.viewModelScope,\n      onValue: { [weak self] in self?.user = $0 }\n    )\n  }\n\n  func getUser() { self.commonVm.getUser() }\n\n  deinit {\n    self.commonVm.clear()\n  }\n}\n</code></pre> <p>For more details, please check kmp viewmodel sample.</p>"},{"location":"viewmodel/","title":"Get started","text":""},{"location":"viewmodel/#1-add-dependency","title":"1. Add dependency","text":"<ul> <li>Add <code>mavenCentral()</code> to <code>repositories</code> list in <code>build.gradle.kts</code>/<code>settings.gradle.kts</code>.</li> </ul> <pre><code>// settings.gradle.kts\ndependencyResolutionManagement {\n[...]\nrepositories {\nmavenCentral()\n[...]\n}\n}\n</code></pre> <ul> <li>Add dependency to <code>build.gradle.kts</code> of your shared module (must use <code>api</code> configuration).</li> </ul> <pre><code>// build.gradle.kts\nkotlin {\nsourceSets {\nval commonMain by getting {\ndependencies {\napi(\"io.github.hoc081098:kmp-viewmodel:0.4.0\")\n}\n}\n}\n}\n</code></pre> <ul> <li>Expose <code>kmp-viewmodel</code> to <code>Darwin</code> native side.</li> </ul> <pre><code>// Cocoapods\nkotlin {\ncocoapods {\n[...]\nframework {\nbaseName = \"shared\"\nexport(\"io.github.hoc081098:kmp-viewmodel:0.4.0\") // required to expose the classes to iOS.\n}\n}\n}\n\n// -- OR --\n\n// Kotlin/Native as an Apple framework\nkotlin {\nios {\nbinaries {\nframework {\nbaseName = \"shared\"\nexport(\"io.github.hoc081098:kmp-viewmodel:0.4.0\") // required to expose the classes to iOS.\n}\n}\n}\n}\n</code></pre> Snapshots of the development version are available in Sonatype's snapshots repository. <p> <pre><code>// settings.gradle.kts\ndependencyResolutionManagement {\nrepositoriesMode.set(RepositoriesMode.PREFER_PROJECT)\nrepositories {\nmaven(url = \"https://s01.oss.sonatype.org/content/repositories/snapshots/\")\n[...]\n}\n}\n\n// build.gradle.kts\ndependencies {\napi(\"io.github.hoc081098:kmp-viewmodel:0.4.1-SNAPSHOT\")\n}\n</code></pre> </p>"},{"location":"viewmodel/#2-overview","title":"2. Overview","text":"<pre><code>public expect abstract class ViewModel {\npublic constructor()\npublic constructor(vararg closeables: Closeable)\n\npublic val viewModelScope: CoroutineScope\npublic fun addCloseable(closeable: Closeable)\n\nprotected open fun onCleared()\n}\n</code></pre> <ul> <li> <p>The ViewModel has a <code>viewModelScope</code> which is a <code>CoroutineScope</code> that is cancelled when the   ViewModel   is cleared. Once the ViewModel is cleared, all coroutines launched in this scope will be   cancelled.</p> </li> <li> <p><code>addCloseable</code> method is used to add <code>Closeable</code> that will be closed directly before <code>onCleared</code>   is called.</p> </li> <li> <p><code>onCleared</code> is called when the ViewModel is cleared, you can override this method to do some clean   up work.   But it is recommended to use the <code>addCloseable</code> method instead of overriding <code>onCleared</code> method.</p> </li> </ul>"},{"location":"viewmodel/#3-create-your-viewmodel-in-commonmain-source-set","title":"3. Create your <code>ViewModel</code> in <code>commonMain</code> source set.","text":"<pre><code>import com.hoc081098.kmp.viewmodel.Closeable\nimport com.hoc081098.kmp.viewmodel.ViewModel\nimport com.hoc081098.kmp.viewmodel.wrapper.NonNullFlowWrapper\nimport com.hoc081098.kmp.viewmodel.wrapper.NonNullStateFlowWrapper\nimport com.hoc081098.kmp.viewmodel.wrapper.wrap\n\nclass ProductsViewModel(\nprivate val getProducts: GetProducts,\n) : ViewModel() {\nprivate val _eventChannel = Channel&lt;ProductSingleEvent&gt;(Int.MAX_VALUE)\nprivate val _actionFlow = MutableSharedFlow&lt;ProductsAction&gt;(Int.MAX_VALUE)\n\nval stateFlow: NonNullStateFlowWrapper&lt;ProductsState&gt;\nval eventFlow: NonNullFlowWrapper&lt;ProductSingleEvent&gt; = _eventChannel.receiveAsFlow().wrap()\n\ninit {\n// Close _eventChannel when ViewModel is cleared.\naddCloseable(_eventChannel::close)\n\nstateFlow = _actionFlow\n.transformToStateFlow()\n.stateIn(\nscope = viewModelScope,\nstarted = SharingStarted.Eagerly,\ninitialValue = ProductsState.INITIAL,\n)\n.wrap()\n}\n\n// Do business logic here, to convert `ProductsAction`s to `ProductsState`s.\nprivate fun SharedFlow&lt;ProductsAction&gt;.transformToStateFlow(): Flow&lt;ProductsState&gt; = TODO()\n\nfun dispatch(action: ProductsAction) {\n_actionFlow.tryEmit(action)\n}\n}\n</code></pre>"},{"location":"viewmodel/#4-use-common-viewmodel-in-each-platform","title":"4. Use common <code>ViewModel</code> in each platform.","text":""},{"location":"viewmodel/#41-android","title":"4.1. Android","text":"<p>Use the <code>ViewModel</code> as a normal <code>AndroidX Lifecycle ViewModel</code>.</p> <pre><code>import androidx.lifecycle.viewmodel.compose.viewModel\n\n@Composable\nfun ProductsScreen(\nviewModel: ProductsViewModel = viewModel(),\n) {\nval state by viewModel.stateFlow.collectAsStateWithLifecycle()\n// Render UI based on state.\n}\n</code></pre>"},{"location":"viewmodel/#42-non-android","title":"4.2. non-Android","text":"<ul> <li> <p>Make sure that you call <code>clear()</code> on your ViewModel when it\u2019s no longer needed,   to properly cancel the <code>CoroutineScope</code> and close resources.   For example, you should call <code>clear()</code> in <code>deinit</code> block when using <code>ViewModel</code> in <code>Darwin</code>   targets (<code>ios</code>, <code>macos</code>, <code>tvos</code>, <code>watchos</code>).</p> </li> <li> <p>In addition, you should create a wrapper of the common <code>ViewModel</code> in each platform and use   flow wrappers provided by this library (<code>NonNullFlowWrapper</code>, <code>NullableFlowWrapper</code>   , <code>NonNullStateFlowWrapper</code>, <code>NullableStateFlowWrapper</code>), to consume   the common <code>ViewModel</code> easily and safely.</p> </li> </ul> <p>For more details, please check kmp viewmodel sample.</p> <p>The below example is using <code>NonNullStateFlowWrapper.subscribe(scope:onValue:)</code> method to consume the <code>Flow</code>s in <code>Darwin</code> targets (Swift language).</p> <pre><code>@MainActor\nclass IosProductsViewModel: ObservableObject {\n  private let commonVm: ProductsViewModel\n\n  @Published private(set) var state: ProductsState\n\n  init(commonVm: ProductsViewModel) {\n    self.commonVm = commonVm\n\n    self.state = self.commonVm.stateFlow.value\n    self.commonVm.stateFlow.subscribe(\n      scope: self.commonVm.viewModelScope,\n      onValue: { [weak self] in self?.state = $0 } // use weak self to avoid retain cycle.\n    )\n  }\n\n  func dispatch(action: ProductsAction) { self.commonVm.dispatch(action: action) }\n\n  deinit { self.commonVm.clear() }\n}\n</code></pre>"}]}